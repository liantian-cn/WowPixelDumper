# EZPixelDumperX2

---

## 1. 截图库对比 性能 可控性 遮挡能力

这一块我前后试了不少方案 最后感受很直接 就是数据看起来差不多但长期跑起来差别非常大

| 方案 | 速度 | 优点 | 缺点 | 遮挡窗口可抓取 |
|---|---:|---|---|---|
| Desktop Duplication API | ~100 FPS | 性能高 速度可控 链路稳定 | 无法截取被遮挡窗口 | ❌ |
| Windows.Graphics.Capture | ~160 FPS | 性能更高 可截取被遮挡窗口 | 速度不可控 必须吃下所有 frame 后处理压力更大 | ✅ |
| GDI | ~15 FPS | 上手直观 | 性能太低 不适合高频解析 | ✅ |

最后项目选了 **Desktop Duplication API** 不是因为它理论峰值最高 而是它在实际运行里节奏更稳 而且可以按目标帧率工作 这样抓图线程和后面的解析线程不会互相拉扯

---

## 2. 统一转成 `ndarray` 的理由

这件事本质上是为了把所有重计算都交给 `numpy` 因为模板匹配 亮度计算 纯色判断 白点计数 余弦相似度这些东西一旦进了 `ndarray` 通路就能保持很高的一致性和吞吐 而且代码层面也会干净很多

- 模板匹配和数值计算都直接吃 `ndarray`
- 主通路几乎不做来回格式转换
- `Node` 和 `PixelBlock` 也都是按数组切片在做协议化计算

---

## 3. 哈希方案 `xxhash`

图标识别里最频繁的动作就是算哈希 所以这里选型非常现实 就是要快并且稳定 在这个点上 `xxhash` 比常规 `hashlib` 方案更合适

- 项目里用 `xxh3_64_hexdigest` 计算中间 6x6 的哈希
- 节点内部有哈希缓存 避免重复算
- 标题库先走 O(1) 的哈希命中 命不中再走余弦相似度

---

## 4. Dumper 和 Rotation 分离的目的

这个分离不是为了架构好看 而是为了让抓图解析这一侧一直保持稳定频率 不会被决策逻辑阻塞 这样你在 Rotation 里做再复杂的判断 也不会反向拖慢采集链路

- Dumper 负责抓图 像素协议解析 JSON 输出
- Rotation 负责策略和决策
- 两边通过本地 HTTP 对接 互相解耦

另外 Dumper 内部本身也做了解耦 `CameraWorker` 持续抓帧 `WebServerWorker` 独立提供 API UI 线程只负责控制和展示

---

## 5. 抗干扰校验 先验证再解析

实际运行时最怕的不是慢 而是错 所以每一帧都先做锚点校验 只要发现这帧不可信就直接返回错误 JSON 这样下游拿到的数据至少是可判断的 而不是看起来像成功其实全是脏数据

- `(1,16)` 和 `(50,1)` 必须黑色
- `(1,1)` 与 `(50,16)` 必须纯色并且同色
- `(51,4)` 必须非纯色
- 闪烁位必须在黑白稳定态

---

## 6. 工程细节里比较实用的点

- 互斥锁保证单实例 设备不会被多开抢占
- API 用 catch all 路由 调用端接入简单
- `pixel_dump` 常驻内存对象 服务端读取开销低

---

## 7. 改成采集卡输入 可行方案和注意事项

如果来源不再是屏幕而是采集卡 Debian 13 上可以直接按下面的方式读取 然后把 `frame` 转成 RGB 后继续走现有解析链路

```python
import cv2
import numpy as np
 
cap = cv2.VideoCapture('/dev/video2')   # 改成你的采集卡编号

if not cap.isOpened():
    print("无法打开采集卡")
    exit()

while True:
    ret, frame = cap.read()
    if not ret:
        print("读取失败")
        break
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
```

这里有两点非常关键 第一是尽量用高性能 RGB24 原始采集卡 因为很多廉价卡会做 H.264 或 H.265 压缩 压缩后像素特征会被破坏 哈希和相似度都会受影响 第二是采集卡链路通常受限于视频源刷新率 常见上限就是 60Hz 所以你的总体帧率预期也要按这个上限来估计

## 8. Node 可用区域要收缩
   - 8x8 的 Node 真正稳定可用的是中间 6x6
   - 队友 4x4 的 Node 真正稳定可用的是中间 2x2
   - 原因很简单 你并不知道抗锯齿到底改了哪些边缘像素 所以边缘信息不可靠
   - 2x2 已经做不出稳定有效的哈希 所以图标最小设计必须是 8x8

