# Rebuild 指南（跨语言）

本文只描述 `Dumper\` 与 `Dumper.NET\` 共同的业务逻辑，不限定具体编程语言或 UI 框架。

## 1. 业务目标

- 从屏幕实时捕获一块像素数据区域。
- 将该区域按 `8x8` 像素切分为逻辑节点。
- 按固定坐标协议解析为结构化状态（玩家、目标、焦点、小队、技能、光环等）。
- 通过本地 HTTP API 输出 JSON，供外部系统轮询消费。
- 支持图标标题库（hash 精确匹配 + 余弦相似度匹配 + 人工补录）。

## 2. 核心流程（端到端）

1. 枚举显示器输出并选择目标输出。
2. 采集一帧全屏图。
3. 在全屏图中查找模板 `mark8.png`，必须匹配到 **2 个**锚点。
4. 用两个锚点求最小包围矩形，且宽高都必须是 `8` 的倍数。
5. 启动循环采集，仅截取该矩形区域。
6. 每帧先做遮挡/有效性校验，失败则返回错误 JSON。
7. 校验通过后进行节点解析与结构化提取。
8. 更新内存中的最新 `pixel_dump`，HTTP API 始终返回该对象。

## 3. 像素协议与节点模型

## 3.1 节点分层

- `full`: 8x8，完整图标内容。
- `middle`: 6x6（去边框），用于 hash 与标题识别。
- `inner`: 4x4，用于亮度、纯色、百分比、颜色判定。
- `mix/sub`: 四个 2x2 子块（左上、右上、左下、右下），用于冷却、可用性、高亮、已学会等复合信息。
- `footnote`: 右下 2x2，用于图标类型分类（IconType）。

## 3.2 关键计算规则

- 纯色：区域内所有像素一致。
- 黑/白判定：纯色且 RGB 为 `(0,0,0)` / `(255,255,255)`。
- 百分比：`mean / 255 * 100`。
- 白点计数：统计白色像素数量，用于定制数字字体解析。
- 剩余时间（亮度反解）：按分段线性插值  
  `(0,0) (5,100) (30,150) (155,200) (375,255)`。

## 4. 标题库（NodeTitleManager）业务规则

- 持久化：SQLite 表 `node_titles`。
- 关键字段：`middle_hash`、`title`、`match_type`、`footnote_title`、`full_data`。
- 匹配优先级：
1. `middle_hash` 精确命中。
2. 与缓存图标做余弦相似度比较，超过阈值（默认 `0.995`）则自动命中并写库（`cosine`）。
3. 否则记为未匹配，返回 hash 本身，等待人工补录。
- 需提供：
1. 记录增删改查。
2. 未匹配列表与会话相似度列表。
3. 阈值调整。
4. JSON 导入导出。

## 5. 遮挡/有效性校验（必须先于解析）

使用以下锚点规则：

- `(1,16)` 必须黑色。
- `(50,1)` 必须黑色。
- `(1,1)` 与 `(50,16)` 必须是纯色且颜色相同。
- `(51,4)` 必须是非纯色（数据区）。

任一失败，返回：

- `error`: 游戏窗口被遮挡或插件未加载...
- `details`: 失败原因列表。

## 6. 结构化输出协议（JSON 形状）

顶层：

- `timestamp`
- `misc`
- `spec`
- `player`
- `target`
- `focus`
- `party`
- `signal`

重要子结构：

- `player.spell_sequence / player.spell`：技能列表与字典。
- `*.aura.buff_sequence/debuff_sequence`：光环序列。
- `*.status`：血量、距离、施法、职业、职责、战斗状态等。
- `party1..party4`：每个队友独立结构。

该坐标协议是重构时最关键契约，建议先固化为常量/配置，再做引擎实现。

## 7. API 约定

- 默认监听：`http://127.0.0.1:65131/`（或等价地址）。
- 任意路径统一返回当前 `pixel_dump` JSON。
- 建议开启 CORS（`*`）方便本地集成。

## 8. 运行时与工程约束

- 单实例运行（互斥锁）。
- 采集与 UI 解耦（后台线程/任务）。
- 停止采集时应回写统一状态：`{"error":"已停止"}`。
- 异常不应崩溃主进程，需可见日志与可恢复状态。

## 9. 重构建议顺序

1. 先实现“采集 + 锚点定位 + 遮挡校验 + 固定测试图回放”。
2. 再实现 Node/Extractor 与 `ExtractAllData` 坐标协议。
3. 再接标题库与相似度匹配。
4. 最后接 GUI 与图标库运营界面。

